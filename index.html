<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QR-dle: The QR Code Puzzle</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <style>
        /* Custom font */
        body { font-family: 'Inter', sans-serif; }
        
        /* Style the canvas container for an app-like view */
        .canvas-container {
            overflow: hidden;
            border: 4px solid #374151; /* Dark border for a more technical look */
            background-color: #f8f8f8;
            cursor: grab;
            user-select: none;
            touch-action: none;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.15), inset 0 2px 8px rgba(0, 0, 0, 0.1);
            aspect-ratio: 1 / 1; /* Keep the container square */
        }
        
        /* Custom style for the hint counter bubble */
        .hint-counter {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
            background-color: #F87171; /* Red-400 */
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.4);
            transition: background-color 0.2s;
        }

        /* Base style for all main action buttons for tactile feel */
        .action-button-base {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            border-bottom: 3px solid rgba(0, 0, 0, 0.15); /* Subtle 3D effect */
        }
        .action-button-base:hover:not(:disabled) {
             box-shadow: 0 6px 10px -2px rgba(0, 0, 0, 0.2), 0 3px 5px -3px rgba(0, 0, 0, 0.1);
             transform: translateY(-2px);
             border-bottom-width: 1px;
        }
        .action-button-base:active:not(:disabled) {
            transform: translateY(1px);
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
            border-bottom-width: 0;
        }
        .action-button-base:disabled {
            box-shadow: none;
            cursor: not-allowed;
            border-bottom: 3px solid rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-start py-8">

    <header class="w-full bg-gray-800 text-white shadow-lg sticky top-0 z-10">
        <div class="max-w-xl mx-auto p-4 flex justify-between items-center">
             <h1 class="text-xl font-bold">QR-dle üß©</h1>
             <span class="text-sm font-light text-gray-400">Guess the Code!</span>
        </div>
    </header>

    <div class="w-full max-w-xl bg-white shadow-2xl rounded-xl p-6 md:p-8 space-y-6 mt-4">
        <h2 class="text-3xl font-extrabold text-gray-900 text-center">
             The Code Puzzle ‚óºÔ∏è
        </h2>
        <p class="text-center text-gray-600 text-sm md:text-base border-b pb-4 border-gray-200">
             <span class="font-bold text-red-600">Rule:</span> You get **<span id="placementLimit">6</span> placements per check** to toggle a square. Undoing a guess returns the slot. **Green squares are locked.**
        </p>

        <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-3">
            <!-- Mode Selector -->
            <select id="modeSelect" 
                    class="p-3 border border-gray-300 rounded-lg shadow-inner bg-white flex-shrink-0 w-full sm:w-auto focus:ring-indigo-500 focus:border-indigo-500 transition">
                <option value="QR">QR Code Puzzle (Square)</option>
                <option value="rMQR">rMQR Puzzle (Rectangular)</option>
                <option value="BARCODE">Barcode Puzzle (Code 39)</option>
            </select>

            <!-- Version Selector (Dynamic Visibility/Content) -->
            <select id="versionSelect" 
                    class="p-3 border border-gray-300 rounded-lg shadow-inner bg-white flex-shrink-0 w-full sm:w-auto focus:ring-indigo-500 focus:border-indigo-500 transition">
                <!-- Options populated by JavaScript -->
            </select>
        </div>

        <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-3">
            <input type="url" id="urlInput" value="QRDLE" placeholder="Enter URL or Text"
                    class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 shadow-inner transition">
            <button id="generateButton"
                    class="action-button-base px-4 py-3 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-500 focus:ring-opacity-50">
                 ‚ú® Generate Target
            </button>
        </div>
        
        <div class="flex justify-center pt-2">
            <button id="saveButton" 
                    style="display: none;"
                    class="action-button-base w-full md:w-auto px-6 py-2 bg-purple-600 text-white font-semibold rounded-lg hover:bg-purple-700 focus:outline-none focus:ring-4 focus:ring-purple-500">
                 üíæ Save Solution
            </button>
        </div>

        <div id="statusMessage" class="text-center p-3 text-sm rounded-lg font-medium bg-blue-100 text-blue-800 transition border border-blue-300">
             Enter content and click "Generate Target" to begin the puzzle.
        </div>

        <hr class="border-gray-300">

        <div class="space-y-4">
            <div class="flex flex-wrap justify-center space-x-2 md:space-x-3">
                <button id="zoomOutButton" class="my-1 px-4 py-2 text-sm bg-gray-200 text-gray-700 font-medium rounded-lg shadow-md hover:bg-gray-300 transition focus:ring-2 focus:ring-gray-400">
                     <span class="font-bold">‚àí</span> Zoom Out
                </button>
                <button id="resetViewButton" class="my-1 px-4 py-2 text-sm bg-blue-100 text-blue-700 font-medium rounded-lg shadow-md hover:bg-blue-200 transition focus:ring-2 focus:ring-blue-400">
                     <span class="font-bold">‚åÇ</span> Reset View
                </button>
                <button id="zoomInButton" class="my-1 px-4 py-2 text-sm bg-gray-200 text-gray-700 font-medium rounded-lg shadow-md hover:bg-gray-300 transition focus:ring-2 focus:ring-gray-400">
                     <span class="font-bold">+</span> Zoom In
                </button>
            </div>

            <div class="canvas-container w-full aspect-square mx-auto rounded-xl">
                <canvas id="qrCanvas" width="500" height="500"></canvas>
            </div>
        </div>

        <div class="flex flex-col md:flex-row justify-center space-y-3 md:space-y-0 md:space-x-4 mt-6">
            <button id="checkButton" disabled
                    class="action-button-base flex-grow px-8 py-3 bg-indigo-600 text-white font-semibold rounded-lg opacity-50
                            focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50 hover:bg-indigo-700">
                 ‚úÖ Check Pattern
            </button>
            <button id="hintButton" disabled
                    class="action-button-base relative flex-grow px-8 py-3 bg-yellow-500 text-white font-semibold rounded-lg opacity-50
                            focus:outline-none focus:ring-4 focus:ring-yellow-500 hover:bg-yellow-600">
                 üí° Hint
                 <span id="hintCounter" class="hint-counter">3</span>
            </button>
        </div>
        
        <!-- HISTORY BUTTON -->
        <div class="flex justify-center mt-3">
            <button id="checkedSquaresButton"
                    class="action-button-base w-full px-8 py-3 bg-fuchsia-600 text-white font-semibold rounded-lg 
                           hover:bg-fuchsia-700 focus:outline-none focus:ring-4 focus:ring-fuchsia-500 disabled:opacity-50 transition duration-150">
                <span class="text-sm md:text-base">Show Click History (One-Time)</span>
                <span class="block text-xs font-light mt-1 opacity-70">(Reveals all checked squares)</span>
            </button>
        </div>

        <div id="messageBox" class="text-center p-4 mt-4 text-sm rounded-lg font-bold bg-gray-100 text-gray-700 border-2 border-gray-200 shadow-inner">
             <p>Ready to generate a pattern!</p>
             <p class="mt-2 text-xs text-gray-500">The detailed score breakdown and missing quadrant hint will appear here after your first check.</p>
        </div>
        
        <div class="flex justify-center mt-8 pt-4 border-t border-gray-300">
             <button id="clearButton"
                    class="action-button-base w-full md:w-auto px-8 py-3 bg-red-100 text-red-700 font-semibold rounded-lg hover:bg-red-200 focus:outline-none focus:ring-4 focus:ring-red-500">
                 <span class="text-lg leading-none align-middle mr-1">üóëÔ∏è</span> Wipe Grid
             </button>
        </div>
    </div>
    
    <div class="p-4 text-center text-xs text-gray-500 mt-4 max-w-xl">
        Hint color codes: Green=Correct/Locked, Red=Wrong/No match, Yellow/Orange/Dark Red=Proximity match (1-4 adjacent correct modules). **Purple circles show click history.**
    </div>

    <script>
        // --- Core Configuration ---
        const CANVAS_DIMENSION = 500; 
        const MAX_DRAWING_AREA = 400; 
        const BLACK_COUNT_BUFFER = 100; // UPDATED: Max allowed black squares is 100 more than solution total
        let MAX_PLACEMENTS_PER_ROUND = 6; 
        const MAX_HINTS = 3; 
        const EXPORT_SIZE = 500; 
        
        // View/Interaction Constants
        const MIN_SCALE = 0.5;
        const MAX_SCALE = 5.0; 
        const BARCODE_MAX_SCALE = 15.0; // UPDATED: Increased max zoom for Barcode mode
        const MOVEMENT_TOLERANCE = 5; 
        const DRAG_DELAY_MS = 200; 


        // Placement Limits by QR Version/Mode
        const MAX_PLACEMENTS_LOOKUP = {
            '1': 6,  
            '5': 10, 
            '10': 15, 
            '20': 20, 
            'BARCODE': 8, // UPDATED
            'RM2': 4,  // UPDATED
            'RM3': 6, // UPDATED
            'RM4': 9, // UPDATED
            'DEFAULT': 6
        };

        // Dimensions for rMQR puzzles (Height x Width)
        const RMQR_DIMENSIONS = {
            'RM2': { h: 9, w: 15 },
            'RM3': { h: 11, w: 27 },
            'RM4': { h: 13, w: 35 }
        };

        // --- SELECT OPTION DEFINITIONS ---
        const QR_OPTIONS = [
            { value: '1', text: 'Version 1 (21x21 | 6 Placements)' },
            { value: '5', text: 'Version 5 (37x37 | 10 Placements)' },
            { value: '10', text: 'Version 10 (57x57 | 15 Placements)' },
            { value: '20', text: 'Version 20 (99x99 | 20 Placements)' },
        ];
        const RMQR_OPTIONS = [
            { value: 'RM2', text: 'RM2 (9x15 | 4 Placements)' },
            { value: 'RM3', text: 'RM3 (11x27 | 6 Placements)' },
            { value: 'RM4', text: 'RM4 (13x35 | 9 Placements)' },
        ];
        const BARCODE_OPTIONS = [
             { value: 'BARCODE', text: 'Code 39 (Dynamic W x 10 | 8 Placements)' },
        ];
        
        // --- Code 39 Encoding Utility ---
        const Code39 = {
            // N=Narrow (1 module), W=Wide (3 modules)
            // Pattern order: Bar1, Space1, Bar2, Space2, Bar3, Space3, Bar4, Space4, Bar5
            // 0 = Narrow, 1 = Wide
            ENCODING: {
                '0': [0,0,0,1,1,0,1,0,0], '1': [1,0,0,1,0,0,0,0,1], '2': [0,0,1,1,0,0,0,0,1],
                '3': [1,0,1,1,0,0,0,0,0], '4': [0,0,0,1,1,0,0,0,1], '5': [1,0,0,1,1,0,0,0,0],
                '6': [0,0,1,1,1,0,0,0,0], '7': [0,0,0,1,0,0,1,0,1], '8': [1,0,0,1,0,0,1,0,0],
                '9': [0,0,1,1,0,0,1,0,0], 'A': [1,0,0,0,0,1,0,0,1], 'B': [0,0,1,0,0,1,0,0,1],
                'C': [1,0,1,0,0,1,0,0,0], 'D': [0,0,0,0,1,1,0,0,1], 'E': [1,0,0,0,1,1,0,0,0],
                'F': [0,0,1,0,1,1,0,0,0], 'G': [0,0,0,0,0,1,1,0,1], 'H': [1,0,0,0,0,1,1,0,0],
                'I': [0,0,1,0,0,1,1,0,0], 'J': [0,0,0,0,1,1,1,0,0], 'K': [1,0,0,0,0,0,0,1,1],
                'L': [0,0,1,0,0,0,0,1,1], 'M': [1,0,1,0,0,0,0,1,0], 'N': [0,0,0,0,1,0,0,1,1],
                'O': [1,0,0,0,1,0,0,1,0], 'P': [0,0,1,0,1,0,0,1,0], 'Q': [0,0,0,0,0,0,1,1,1],
                'R': [1,0,0,0,0,0,1,1,0], 'S': [0,0,1,0,0,0,1,1,0], 'T': [0,0,0,0,1,0,1,1,0],
                'U': [1,1,0,0,0,0,0,0,1], 'V': [0,1,1,0,0,0,0,0,1], 'W': [1,1,1,0,0,0,0,0,0],
                'X': [0,1,0,0,1,0,0,0,1], 'Y': [1,1,0,0,1,0,0,0,0], 'Z': [0,1,1,0,1,0,0,0,0],
                '-': [0,1,0,0,0,0,1,0,1], '.': [1,1,0,0,0,0,1,0,0], ' ': [0,1,1,0,0,0,1,0,0],
                '$': [0,1,0,1,0,1,0,0,0], '/': [0,1,0,1,0,0,0,1,0], '+': [0,1,0,0,0,1,0,1,0],
                '%': [0,0,0,1,0,1,0,1,0], '*': [0,1,0,0,1,0,1,0,0] // Start/Stop
            },
            // Generates the final module pattern (1=Black Bar, 0=White Space)
            encode: function(data) {
                // Ensure data is uppercase and includes only valid characters
                const upperData = data.toUpperCase().replace(/[^0-9A-Z\-\.\$\/\+\%\s]/g, '');
                
                // Add start and stop character
                const fullData = '*' + upperData + '*';
                
                let modulePattern = [];
                const narrowWidth = 1;
                const wideWidth = 3;
                const interCharGap = 1; // 1 narrow module space between characters

                for (let i = 0; i < fullData.length; i++) {
                    const char = fullData[i];
                    const pattern = this.ENCODING[char];

                    if (!pattern) continue; // Should not happen with cleaning above

                    // Process 5 bars and 4 spaces (9 elements total)
                    for (let j = 0; j < 9; j++) {
                        const isWide = pattern[j] === 1;
                        const width = isWide ? wideWidth : narrowWidth;
                        const isBar = j % 2 === 0;

                        // Add modules to the pattern
                        for (let k = 0; k < width; k++) {
                            modulePattern.push(isBar ? 1 : 0);
                        }
                    }

                    // Add inter-character gap (unless it's the last character)
                    if (i < fullData.length - 1) {
                        for (let k = 0; k < interCharGap; k++) {
                            modulePattern.push(0); // White space
                        }
                    }
                }
                return modulePattern;
            },
            getRequiredWidth: function(data) {
                // Calculates total modules based on the encoded data length
                const charCount = data.toUpperCase().replace(/[^0-9A-Z\-\.\$\/\+\%\s]/g, '').length + 2;
                // Total modules per char segment (including trailing gap) = 16
                // Subtract 1 module because the last inter-char gap is not added after the stop character.
                return (charCount * 16) - 1; 
            },
            getMaxLength: function() {
                // Maximum comfortable length for the canvas to display clearly
                return 30; 
            }
        };

        // --- Global State Variables ---
        let GRID_WIDTH = 0;
        let GRID_HEIGHT = 0;
        let moduleWidth = 0;
        let moduleHeight = 0; 
        
        let solutionData = []; 
        let totalSolutionBlack = 0; 
        let userData = []; 
        let currentBlackCount = 0; 
        let isCellChanged = false; 
        let placementsThisRound = []; 
        let hintsRemaining = MAX_HINTS; 
        let hintedCells = []; 
        let isSolved = false; 
        
        let lastCheckStatus = []; 
        let puzzleMode = 'QR';
        
        let allClickHistory = []; 
        let pendingClickHistory = []; 
        let isHistoryVisible = false; 
        let isHistoryUsed = false; 
        
        let previousDistance = null; 
        
        let scale = 1.0;
        let panOffset = { x: 0, y: 0 }; 
        let isDragging = false;
        let isTouchDragging = false; 
        let isDrawing = false; 
        let lastMousePos = { x: 0, y: 0 };
        let startClickPos = { x: 0, y: 0 };
        let dragTimer = null; 
        let lastDrawCell = {r: -1, c: -1}; 
        let canvas, ctx;


        const checkButton = document.getElementById('checkButton');
        const hintButton = document.getElementById('hintButton');
        const hintCounter = document.getElementById('hintCounter');
        const saveButton = document.getElementById('saveButton'); 
        const statusMessage = document.getElementById('statusMessage');
        const messageBox = document.getElementById('messageBox');
        const checkedSquaresButton = document.getElementById('checkedSquaresButton');
        const modeSelect = document.getElementById('modeSelect');
        const versionSelect = document.getElementById('versionSelect');
        const placementLimitSpan = document.getElementById('placementLimit');

        // --- Core UI Update Logic ---
        function updatePlacementLimitUI() {
            placementLimitSpan.textContent = MAX_PLACEMENTS_PER_ROUND;
        }

        function updateHintButtonUI() {
            hintCounter.textContent = hintsRemaining;
            
            const isDisabled = hintsRemaining <= 0 || isSolved || solutionData.length === 0;

            hintButton.disabled = isDisabled;
            
            if (isDisabled) {
                hintButton.classList.add('opacity-50', 'cursor-not-allowed');
                hintButton.classList.remove('hover:bg-yellow-600');
            } else {
                hintButton.classList.remove('opacity-50', 'cursor-not-allowed');
                hintButton.classList.add('hover:bg-yellow-600');
            }

            hintButton.classList.remove('bg-yellow-500', 'bg-gray-400');
            hintButton.classList.add(isDisabled ? 'bg-gray-400' : 'bg-yellow-500');
            
            hintCounter.classList.remove('bg-red-500', 'bg-gray-400');
            hintCounter.classList.add(isDisabled ? 'bg-gray-400' : 'bg-red-500');
        }

        function updateCheckedSquaresButtonUI() {
            const shouldBeDisabled = solutionData.length === 0 || isHistoryUsed; 

            checkedSquaresButton.disabled = shouldBeDisabled;
            if (shouldBeDisabled) {
                 checkedSquaresButton.classList.add('opacity-50');
                 checkedSquaresButton.classList.remove('hover:bg-fuchsia-700');
            } else {
                 checkedSquaresButton.classList.remove('opacity-50');
                 checkedSquaresButton.classList.add('hover:bg-fuchsia-700');
            }
        }
        
        function updateVersionSelectorVisibility() {
            const mode = modeSelect.value;
            versionSelect.innerHTML = ''; 
            
            let options = [];
            
            if (mode === 'QR') {
                options = QR_OPTIONS;
            } else if (mode === 'rMQR') {
                options = RMQR_OPTIONS;
            } else if (mode === 'BARCODE') {
                options = BARCODE_OPTIONS;
            }

            options.forEach(opt => {
                const optionElement = document.createElement('option');
                optionElement.value = opt.value;
                optionElement.textContent = opt.text;
                versionSelect.appendChild(optionElement);
            });

            // Set dynamic max placements immediately after updating options
            const selectedVersion = versionSelect.value || (mode === 'QR' ? '1' : (mode === 'rMQR' ? 'RM2' : 'BARCODE'));
            MAX_PLACEMENTS_PER_ROUND = MAX_PLACEMENTS_LOOKUP[selectedVersion] || MAX_PLACEMENTS_LOOKUP.DEFAULT;
            updatePlacementLimitUI();
            
            // Adjust max zoom based on mode
            const currentMaxScale = (mode === 'BARCODE' ? BARCODE_MAX_SCALE : MAX_SCALE);
            // Re-run resetView to apply new initial zoom and center offset
            if (GRID_WIDTH > 0) resetView();
        }
        
        function grantHint() {
            if (hintsRemaining <= 0 || solutionData.length === 0 || isSolved) return;

            hintsRemaining--;
            updateHintButtonUI();

            const potentialHints = [];
            for (let r = 0; r < GRID_HEIGHT; r++) {
                for (let c = 0; c < GRID_WIDTH; c++) {
                    // Only hint cells that should be black but are currently white/unsolved
                    if (solutionData[r][c] === 1 && userData[r][c] === 0 && !hintedCells.some(p => p.r === r && p.c === c)) {
                        potentialHints.push({ r, c });
                    }
                }
            }

            const hintsToSelect = Math.min(3, potentialHints.length);

            for (let i = 0; i < hintsToSelect; i++) {
                const randomIndex = Math.floor(Math.random() * potentialHints.length);
                const hint = potentialHints.splice(randomIndex, 1)[0];
                
                if (puzzleMode === 'BARCODE') {
                    // For Barcode, hint the entire column
                    for (let r = 0; r < GRID_HEIGHT; r++) {
                         // Only add once per column
                         if (r === 0 && !hintedCells.some(p => p.c === hint.c)) {
                            // Store r=-1 as a marker for a full column hint
                            hintedCells.push({ r: -1, c: hint.c }); 
                         }
                    }
                } else {
                    // For QR/rMQR, hint the single cell
                    hintedCells.push(hint);
                }
            }
            
            draw(true);
        }

        // --- Grid Initialization & Generation ---

        function getDistance(touches) {
            if (touches.length < 2) return 0;
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function initializeGrid(width, height) {
            GRID_WIDTH = width;
            GRID_HEIGHT = height;
            
            const ratio = GRID_WIDTH / GRID_HEIGHT;
            let drawWidth, drawHeight;

            if (ratio > 1) { 
                drawWidth = MAX_DRAWING_AREA;
                drawHeight = MAX_DRAWING_AREA / ratio;
            } else { 
                drawHeight = MAX_DRAWING_AREA;
                drawWidth = MAX_DRAWING_AREA * ratio;
            }

            moduleWidth = drawWidth / GRID_WIDTH;
            moduleHeight = drawHeight / GRID_HEIGHT;

            panOffset = { 
                x: (CANVAS_DIMENSION - drawWidth) / 2, 
                y: (CANVAS_DIMENSION - drawHeight) / 2 
            };
            scale = 1.0;

            userData = Array(GRID_HEIGHT).fill(0).map(() => Array(GRID_WIDTH).fill(0));
            lastCheckStatus = Array(GRID_HEIGHT).fill(0).map(() => Array(GRID_WIDTH).fill(0));
            solutionData = Array(GRID_HEIGHT).fill(0).map(() => Array(GRID_WIDTH).fill(0));
            
            isCellChanged = false;
            currentBlackCount = 0;
            placementsThisRound = []; 
            hintsRemaining = MAX_HINTS; 
            isSolved = false; 
            hintedCells = []; 
            
            allClickHistory = [];
            pendingClickHistory = []; 
            isHistoryVisible = false;
            isHistoryUsed = false; 

            updateHintButtonUI();
            updateCheckedSquaresButtonUI();
            updatePlacementLimitUI();

            checkButton.disabled = true;
            checkButton.classList.add('opacity-50', 'cursor-not-allowed');
            checkButton.classList.remove('hover:bg-indigo-700');
            saveButton.style.display = 'none';
        }

        /**
         * Generates a Code 39 Barcode pattern.
         */
        function generateBarcodeTarget(text) {
            // Validate input for Code 39
            const cleanedText = text.toUpperCase().replace(/[^0-9A-Z\-\.\$\/\+\%\s]/g, '');
            const maxLength = Code39.getMaxLength();

            if (!text || cleanedText.length === 0) {
                 statusMessage.textContent = `Please enter valid characters (0-9, A-Z, -.$/+) for the Code 39 Barcode.`;
                 statusMessage.classList.remove('bg-blue-100');
                 statusMessage.classList.add('bg-red-100', 'text-red-800');
                 initializeGrid(60, 10); 
                 return;
            }
            if (cleanedText.length > maxLength) {
                 statusMessage.textContent = `Error: Barcode content too long (${cleanedText.length} > ${maxLength} chars). Max recommended length is ${maxLength}. Please shorten input.`;
                 statusMessage.classList.remove('bg-blue-100');
                 statusMessage.classList.add('bg-red-100', 'text-red-800');
                 initializeGrid(Code39.getRequiredWidth(cleanedText), 10); 
                 return;
            }

            const pattern = Code39.encode(cleanedText);
            const totalModules = pattern.length;

            const BARCODE_HEIGHT = 10;
            
            initializeGrid(totalModules, BARCODE_HEIGHT); 

            totalSolutionBlack = 0;
            for (let r = 0; r < GRID_HEIGHT; r++) {
                for (let c = 0; c < GRID_WIDTH; c++) {
                    if (pattern[c] === 1) { 
                        solutionData[r][c] = 1;
                        totalSolutionBlack++;
                    }
                }
            }

            statusMessage.textContent = `Code 39 Barcode generated for: ${cleanedText}. Grid Size: ${GRID_WIDTH}x${GRID_HEIGHT}. Total black modules: ${totalSolutionBlack}. (Column Toggle Mode Active)`;
            statusMessage.classList.remove('bg-red-100', 'text-red-800');
            statusMessage.classList.add('bg-blue-100', 'text-blue-800');

        }
        
        /**
         * Generates a Rectangular Micro QR pattern (simulated by cropping).
         */
        function generateRmqrTarget(text, version) {
            const { h, w } = RMQR_DIMENSIONS[version];
            
            initializeGrid(w, h);
            
            let sourceQr;
            try {
                // Try to generate V1, fallback to Auto
                sourceQr = qrcode(1, 'L');
                sourceQr.addData(text);
                sourceQr.make();
            } catch (error) {
                sourceQr = qrcode(0, 'L');
                sourceQr.addData(text);
                sourceQr.make();
            }

            const sourceSize = sourceQr.getModuleCount();
            
            const cropRStart = Math.max(0, Math.floor((sourceSize - h) / 2));
            const cropCStart = Math.max(0, Math.floor((sourceSize - w) / 2));

            totalSolutionBlack = 0;
            for (let r = 0; r < h; r++) {
                for (let c = 0; c < w; c++) {
                    const sourceR = cropRStart + r;
                    const sourceC = cropCStart + c;

                    if (sourceR < sourceSize && sourceC < sourceSize) {
                        if (sourceQr.isDark(sourceR, sourceC)) {
                            solutionData[r][c] = 1;
                            totalSolutionBlack++;
                        }
                    }
                }
            }

            statusMessage.textContent = `rMQR Target generated (${version}: ${w}x${h}). Total black modules: ${totalSolutionBlack}.`;
        }


        /**
         * Generates the QR code data for the input URL/text.
         */
        function generateQrTarget(text, version) {
            try {
                const qr = qrcode(version, 'L'); 
                qr.addData(text);
                qr.make();

                const size = qr.getModuleCount();
                initializeGrid(size, size); 
                
                totalSolutionBlack = 0;
                
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (qr.isDark(r, c)) {
                            solutionData[r][c] = 1;
                            totalSolutionBlack++;
                        }
                    }
                }

                let actualVersion = version;
                if (typeof qr.getVersion === 'function') {
                    actualVersion = qr.getVersion();
                } else if (version === 0) {
                     actualVersion = (size - 17) / 4;
                }
                
                statusMessage.textContent = `QR Target generated (Version ${actualVersion}). Grid Size: ${size}x${size}. Total black modules: ${totalSolutionBlack}. You have ${MAX_PLACEMENTS_PER_ROUND} placements remaining this round.`;

            } catch (error) {
                console.error("QR Code Generation Error:", error);
                // More helpful error message for code length overflow
                statusMessage.textContent = 'Error: Content is too long for the selected QR Version (capacity overflow). Try a shorter input or select a larger version.';
                statusMessage.classList.remove('bg-blue-100');
                statusMessage.classList.add('bg-red-100', 'text-red-800');
                solutionData = []; 
                hintButton.disabled = true;
                hintButton.classList.add('opacity-50', 'cursor-not-allowed');
                saveButton.style.display = 'none';
                return;
            }
        }
        
        /**
         * Main entry point for generating the target based on mode selection.
         */
        function generateTarget() {
            const content = document.getElementById('urlInput').value.trim();
            const mode = modeSelect.value;
            const version = versionSelect.value;

            if (!content) {
                statusMessage.textContent = 'Please enter content before generating a target pattern.';
                statusMessage.classList.remove('bg-blue-100', 'bg-green-100', 'bg-yellow-200');
                statusMessage.classList.add('bg-red-100', 'text-red-800');
                return;
            }
            
            puzzleMode = mode;
            
            // Set dynamic max placements based on mode/version
            MAX_PLACEMENTS_PER_ROUND = MAX_PLACEMENTS_LOOKUP[version] || MAX_PLACEMENTS_LOOKUP.DEFAULT;

            // Reset message box and generate
            messageBox.classList.remove('bg-red-100', 'bg-green-100', 'text-red-800', 'text-green-800', 'bg-yellow-100', 'text-yellow-800', 'border-red-200', 'border-green-200', 'border-yellow-200', 'bg-fuchsia-100', 'text-fuchsia-800', 'border-fuchsia-200');
            messageBox.classList.add('bg-gray-100', 'text-gray-700', 'border-gray-200');
            messageBox.innerHTML = `<p><strong>Puzzle Ready:</strong> Start guessing the pattern using your ${MAX_PLACEMENTS_PER_ROUND} placements per check.</p><p class="mt-2 text-xs text-gray-500">Use the color hints after checking to guide your next round!</p>`;


            if (mode === 'QR') {
                generateQrTarget(content, parseInt(version));
            } else if (mode === 'BARCODE') {
                generateBarcodeTarget(content);
            } else if (mode === 'rMQR') {
                generateRmqrTarget(content, version);
            }

            updateHintButtonUI();
            updateCheckedSquaresButtonUI();
            updatePlacementLimitUI();
            draw(true);
        }

        /**
         * Checks how many correct black modules are adjacent (up, down, left, right) to the given cell.
         */
        function getAdjacentBlackCount(r, c) {
            let count = 0;
            const directions = [
                [0, 1], [0, -1], [1, 0], [-1, 0] 
            ];
            
            for (const [dr, dc] of directions) {
                const nr = r + dr;
                const nc = c + dc;

                if (nr >= 0 && nr < GRID_HEIGHT && nc >= 0 && nc < GRID_WIDTH) {
                    if (solutionData[nr][nc] === 1) {
                        count++;
                    }
                }
            }
            return count;
        }

        /**
         * Compares the user's pattern against the solution and updates the visual feedback.
         */
        function checkPattern() {
            if (!isCellChanged) return;
            
            const maxAllowedBlack = totalSolutionBlack + BLACK_COUNT_BUFFER;

            if (currentBlackCount > maxAllowedBlack) {
                // Failsafe hit - Clear pending history
                pendingClickHistory = [];
                
                messageBox.classList.remove('bg-yellow-100', 'bg-green-100', 'text-yellow-800', 'text-green-800', 'bg-gray-100', 'text-gray-700', 'border-yellow-200', 'border-green-200', 'border-gray-200', 'bg-fuchsia-100', 'text-fuchsia-800', 'border-fuchsia-200');
                messageBox.classList.add('bg-red-100', 'text-red-800', 'border-red-200');
                messageBox.innerHTML = `üõë **Failsafe:** You have painted **${currentBlackCount}** black modules, exceeding the max allowed (${maxAllowedBlack}). Remove some black modules to check!`;
                
                isCellChanged = false; 
                checkButton.disabled = true;
                checkButton.classList.add('opacity-50', 'cursor-not-allowed');
                checkButton.classList.remove('hover:bg-indigo-700');
                saveButton.style.display = 'none'; 
                draw(true);
                return; 
            }

            let correctCount = 0;
            const hintCounts = { 4: 0, 5: 0, 6: 0, 7: 0, 2: 0 }; 
            
            const isSquare = (GRID_WIDTH === GRID_HEIGHT);
            const mid = isSquare ? GRID_WIDTH / 2 : 0;
            const missingBlackMap = { TL: 0, TR: 0, BL: 0, BR: 0 };

            for (let r = 0; r < GRID_HEIGHT; r++) {
                for (let c = 0; c < GRID_WIDTH; c++) {
                    
                    if (userData[r][c] === 1) {
                        if (solutionData[r][c] === 1) {
                            lastCheckStatus[r][c] = 1; // Green (Lock status)
                            correctCount++;
                        } else {
                            const adjacentCount = getAdjacentBlackCount(r, c);
                            let status;
                            if (adjacentCount === 1) status = 4;
                            else if (adjacentCount === 2) status = 5;
                            else if (adjacentCount === 3) status = 6;
                            else if (adjacentCount >= 4) status = 7;
                            else status = 2; // Completely Wrong (Red)

                            lastCheckStatus[r][c] = status;
                            hintCounts[status]++;
                        }
                    } else {
                        if (lastCheckStatus[r][c] !== 1) {
                             lastCheckStatus[r][c] = 0; 
                        }
                        
                        // Quadrant analysis only for square QR codes
                        if (solutionData[r][c] === 1 && isSquare) { 
                            const rKey = r < mid ? 'T' : 'B';
                            const cKey = c < mid ? 'L' : 'R';
                            missingBlackMap[rKey + cKey]++;
                        }
                    }
                }
            }

            // --- History Merge (Only successful checks merge pending clicks) ---
            allClickHistory.push(...pendingClickHistory);
            pendingClickHistory = [];
            isHistoryVisible = false; // Hide overlay after check

            // --- Determine Missing Quadrant Hint ---
            let hintMessage = "";
            if (isSquare) {
                let mostMissingQuadrant = 'No quadrant';
                let maxMissing = 0;
                
                for (const key in missingBlackMap) {
                    if (missingBlackMap[key] > maxMissing) {
                        maxMissing = missingBlackMap[key];
                        mostMissingQuadrant = key;
                    }
                }
                
                const readableQuadrant = { TL: "Top Left", TR: "Top Right", BL: "Bottom Left", BR: "Bottom Right" }[mostMissingQuadrant] || 'No quadrant';
                
                if (maxMissing > 0) {
                    hintMessage = `**Missing Hint:** Most missing black squares (${maxMissing}) are located in the **${readableQuadrant}** quadrant.`;
                } else {
                    hintMessage = "You have correctly guessed all the necessary black modules! Check the hint colors to see if you have any misplaced black modules.";
                }
            } else {
                 hintMessage = `Grid dimensions are ${GRID_WIDTH}x${GRID_HEIGHT}. Quadrant analysis is for square QR Codes only.`;
            }


            // --- Check for WIN CONDITION ---
            const isPerfectWin = correctCount === totalSolutionBlack && 
                                 hintCounts[2] === 0 && hintCounts[4] === 0 && 
                                 hintCounts[5] === 0 && hintCounts[6] === 0 && 
                                 hintCounts[7] === 0;

            isSolved = isPerfectWin;
            updateHintButtonUI(); 
            updateCheckedSquaresButtonUI();


            // --- Reset Round State ---
            isCellChanged = false;
            placementsThisRound = []; 
            checkButton.disabled = true;
            checkButton.classList.add('opacity-50', 'cursor-not-allowed');
            checkButton.classList.remove('hover:bg-indigo-700');

            // --- Score Display ---
            const percentage = (totalSolutionBlack > 0) ? (correctCount / totalSolutionBlack) * 100 : 0;
            
            // Score simplification for Barcode mode
            let displayCorrectCount = correctCount;
            let displayTotalBlack = totalSolutionBlack;
            if (puzzleMode === 'BARCODE') {
                // Divide both by the height (10) to show score in terms of bars
                displayCorrectCount = Math.floor(correctCount / GRID_HEIGHT);
                displayTotalBlack = Math.floor(totalSolutionBlack / GRID_HEIGHT);
            }
            
            messageBox.classList.remove('bg-gray-100', 'bg-red-100', 'text-gray-700', 'text-red-800', 'border-red-200', 'border-gray-200', 'border-green-200', 'bg-fuchsia-100', 'text-fuchsia-800', 'border-fuchsia-200');
            
            let finalMessage;

            if (isPerfectWin) {
                messageBox.classList.add('bg-green-100', 'text-green-800', 'border-green-200');
                finalMessage = "üéâ **PERFECT VICTORY!** You solved the entire pattern!";
                saveButton.style.display = 'block';

            } else {
                messageBox.classList.add('bg-yellow-100', 'text-yellow-800', 'border-yellow-200');
                
                finalMessage = `
                    <p class="mb-2"><strong>Score:</strong> ${displayCorrectCount}/${displayTotalBlack} correct black ${puzzleMode === 'BARCODE' ? 'bars' : 'modules'} found (${percentage.toFixed(1)}%).</p>
                    <p class="mb-2">${hintMessage}</p>
                    <hr class="border-yellow-300">
                    <div class="grid grid-cols-2 text-left mt-2 text-xs md:text-sm">
                        <span class="font-normal text-green-600">‚úÖ Correct (Green):</span> <span class="text-right text-green-600">${correctCount}</span>
                        <span class="font-normal text-red-600">üî¥ Fully Wrong (Red):</span> <span class="text-right text-red-600">${hintCounts[2]}</span>
                        <span class="font-normal text-yellow-600">üü° 1 Adjacent (Yellow):</span> <span class="text-right text-yellow-600">${hintCounts[4]}</span>
                        <span class="font-normal" style="color:#CC9900;">üëë 2 Adjacent (Golden Yellow):</span> <span class="text-right" style="color:#CC9900;">${hintCounts[5]}</span>
                        <span class="font-normal text-orange-600">üü† 3 Adjacent (Orange):</span> <span class="text-right text-orange-600">${hintCounts[6]}</span>
                        <span class="font-normal" style="color:#9F1239;">üå∞ 4 Adjacent (Dark Red):</span> <span class="text-right" style="color:#9F1239;">${hintCounts[7]}</span>
                    </div>
                    <p class="mt-4 text-sm">You have **${MAX_PLACEMENTS_PER_ROUND}** placements remaining this round.</p>
                `;
                saveButton.style.display = 'none';
            }
            messageBox.innerHTML = finalMessage;

            draw(true); 
        }

        /**
         * Saves the clean, solution code image by opening it in a new tab.
         */
        function saveSolutionQrCode(event) {
            event.preventDefault(); 
            
            if (saveButton.style.display === 'none') return; 

            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = EXPORT_SIZE;
            exportCanvas.height = EXPORT_SIZE;
            const exportCtx = exportCanvas.getContext('2d');
            
            const scaleFactor = Math.min(EXPORT_SIZE / (GRID_WIDTH * moduleWidth), EXPORT_SIZE / (GRID_HEIGHT * moduleHeight));
            const finalWidth = GRID_WIDTH * moduleWidth * scaleFactor;
            const finalHeight = GRID_HEIGHT * moduleHeight * scaleFactor;

            exportCtx.fillStyle = 'white';
            exportCtx.fillRect(0, 0, EXPORT_SIZE, EXPORT_SIZE);

            const offsetX = (EXPORT_SIZE - finalWidth) / 2;
            const offsetY = (EXPORT_SIZE - finalHeight) / 2;

            for (let r = 0; r < GRID_HEIGHT; r++) {
                for (let c = 0; c < GRID_WIDTH; c++) {
                    if (solutionData[r][c] === 1) {
                        exportCtx.fillStyle = 'black';
                        exportCtx.fillRect(
                            offsetX + c * moduleWidth * scaleFactor, 
                            offsetY + r * moduleHeight * scaleFactor, 
                            moduleWidth * scaleFactor, 
                            moduleHeight * scaleFactor
                        );
                    }
                }
            }
            
            const imageURL = exportCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = imageURL;
            link.target = '_blank'; 
            link.download = `QRdle_Solved_${puzzleMode}_${new Date().toISOString().slice(0, 10)}.png`;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            messageBox.classList.remove('bg-yellow-100', 'bg-red-100', 'text-yellow-800', 'text-red-800', 'bg-gray-100', 'text-gray-700', 'border-red-200', 'border-gray-200', 'border-yellow-200', 'bg-fuchsia-100', 'text-fuchsia-800', 'border-fuchsia-200');
            messageBox.classList.add('bg-green-100', 'text-green-800', 'border-green-200');
            messageBox.innerHTML = `‚úÖ **Success!** The clean solution image has opened in a new tab.`;
            
            setTimeout(() => {
                checkPattern(); 
            }, 3000);
        }

        /**
         * Draws the current state of the grid, including hints and the history overlay.
         */
        function draw(withGridLines = true) {
            ctx.fillStyle = '#f8f8f8';
            ctx.fillRect(0, 0, CANVAS_DIMENSION, CANVAS_DIMENSION);
            ctx.save();

            ctx.translate(panOffset.x, panOffset.y);
            ctx.scale(scale, scale);
            
            const drawWidth = GRID_WIDTH * moduleWidth;
            const drawHeight = GRID_HEIGHT * moduleHeight;

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, drawWidth, drawHeight);

            for (let r = 0; r < GRID_HEIGHT; r++) {
                for (let c = 0; c < GRID_WIDTH; c++) {
                    const status = lastCheckStatus[r][c];
                    let fill = null;
                    
                    if (status === 1) fill = '#10B981'; 
                    else if (status === 2) fill = '#EF4444'; 
                    else if (status === 4) fill = '#FBBF24'; 
                    else if (status === 5) fill = '#CC9900'; 
                    else if (status === 6) fill = '#F97316'; 
                    else if (status === 7) fill = '#9F1239'; 
                    else if (userData[r][c] === 1) fill = 'black'; 
                    else fill = 'white';
                    
                    if (fill && fill !== 'white') {
                        ctx.fillStyle = fill;
                        ctx.fillRect(c * moduleWidth, r * moduleHeight, moduleWidth, moduleHeight);
                    }
                }
            }

            if (isHistoryVisible) {
                ctx.fillStyle = 'rgba(168, 85, 247, 0.5)'; // Fuchsia-600 with transparency
                allClickHistory.forEach(({ r, c }) => {
                    // For Barcode mode, history is tracked by column (r=-1), draw a full vertical bar
                    if (puzzleMode === 'BARCODE' && r === -1) { 
                        ctx.fillRect(c * moduleWidth, 0, moduleWidth, GRID_HEIGHT * moduleHeight);
                    } else if (puzzleMode !== 'BARCODE') {
                         // QR mode: Draw circle over individual cell
                        const centerX = c * moduleWidth + moduleWidth / 2;
                        const centerY = r * moduleHeight + moduleHeight / 2;
                        const radius = Math.min(moduleWidth, moduleHeight) / 3; 
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }

            ctx.fillStyle = 'rgba(59, 130, 246, 0.7)'; // Blue-500 with transparency for hint circles
            hintedCells.forEach(({ r, c }) => {
                
                // For Barcode mode, hint is tracked by column (r=-1), draw a full vertical bar
                if (puzzleMode === 'BARCODE' && r === -1) {
                    ctx.fillRect(c * moduleWidth, 0, moduleWidth, GRID_HEIGHT * moduleHeight);
                } else if (puzzleMode !== 'BARCODE') {
                    // QR mode: Draw circle over individual cell
                    const centerX = c * moduleWidth + moduleWidth / 2;
                    const centerY = r * moduleHeight + moduleHeight / 2;
                    const radius = Math.min(moduleWidth, moduleHeight) / 4;

                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });


            if (withGridLines) {
                const gridColor = '#d1d5db'; 
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 1 / scale; 
                
                for (let i = 0; i <= GRID_WIDTH; i++) {
                    const coord = i * moduleWidth;
                    ctx.beginPath();
                    ctx.moveTo(coord, 0);
                    ctx.lineTo(coord, drawHeight);
                    ctx.stroke();
                }

                for (let i = 0; i <= GRID_HEIGHT; i++) {
                    const coord = i * moduleHeight;
                    ctx.beginPath();
                    ctx.moveTo(0, coord);
                    ctx.lineTo(drawWidth, coord);
                    ctx.stroke();
                }
            }
            
            ctx.restore();
        }
        
        /**
         * Toggles the cell state (white to black) based on game rules.
         */
        function toggleCell(row, col) {
            if (row < 0 || row >= GRID_HEIGHT || col < 0 || col >= GRID_WIDTH || solutionData.length === 0) {
                return false;
            }

            let moveAllowed = true; 
            const isColumnCurrentlyBlack = userData[row][col] === 1;

            if (puzzleMode === 'BARCODE') {
                const column = col;
                
                // 1. Check for Locks
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    if (lastCheckStatus[r][column] === 1) {
                        messageBox.classList.remove('bg-green-100', 'text-green-800', 'bg-yellow-100', 'text-yellow-800', 'bg-gray-100', 'text-gray-700', 'border-yellow-200', 'border-gray-200', 'border-green-200', 'bg-fuchsia-100', 'text-fuchsia-800', 'border-fuchsia-200');
                        messageBox.classList.add('bg-red-100', 'text-red-800', 'border-red-200');
                        messageBox.innerHTML = `üîí **Locked:** This column contains a **correct (Green)** module and cannot be changed!`;
                        draw(true);
                        return false; 
                    }
                }
                
                // 2. Determine Action
                let isPlacement = !isColumnCurrentlyBlack;
                
                if (isPlacement && placementsThisRound.length >= MAX_PLACEMENTS_PER_ROUND) {
                    moveAllowed = false;
                }

                if (!moveAllowed) {
                    messageBox.classList.remove('bg-green-100', 'text-green-800', 'bg-yellow-100', 'text-yellow-800', 'bg-gray-100', 'text-gray-700', 'border-yellow-200', 'border-gray-200', 'border-green-200', 'bg-fuchsia-100', 'text-fuchsia-800', 'border-fuchsia-200');
                    messageBox.classList.add('bg-red-100', 'text-red-800', 'border-red-200');
                    messageBox.innerHTML = `üõë **Placement limit reached!** You must undo one of your **${MAX_PLACEMENTS_PER_ROUND}** column moves this round to place another.`;
                    draw(true);
                    return false; 
                }

                // 3. Apply the Toggle and Update State for the entire column
                const coordKey = `${-1},${column}`;
                const columnHint = { r: -1, c: column, key: coordKey };
                
                if (isPlacement) {
                    currentBlackCount += GRID_HEIGHT;
                    placementsThisRound.push({r: -1, c: column});
                    // Add column marker to pending history
                    if (!pendingClickHistory.some(c => c.key === coordKey)) {
                        pendingClickHistory.push(columnHint);
                    }
                } else {
                    currentBlackCount -= GRID_HEIGHT;
                    const placementIndex = placementsThisRound.findIndex(p => p.c === column && p.r === -1);
                    if (placementIndex !== -1) {
                        placementsThisRound.splice(placementIndex, 1); 
                    }
                    // Remove column marker from pending history
                    pendingClickHistory = pendingClickHistory.filter(c => c.key !== coordKey);
                }
                
                const newValue = isColumnCurrentlyBlack ? 0 : 1;
                
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    userData[r][column] = newValue;
                    lastCheckStatus[r][column] = 0;
                }
                // Remove hints if placed over
                hintedCells = hintedCells.filter(h => h.c !== column);

                isCellChanged = true;
                
            } else { // QR Code & rMQR Mode (Single-cell logic)
                const oldValue = userData[row][col];
                const currentCoords = {r: row, c: col};
                const placementIndex = placementsThisRound.findIndex(p => p.r === row && p.c === col);
                const hintIndex = hintedCells.findIndex(p => p.r === row && p.c === col);

                if (lastCheckStatus[row][col] === 1 && oldValue === 1) {
                    messageBox.classList.remove('bg-green-100', 'text-green-800', 'bg-yellow-100', 'text-yellow-800', 'bg-gray-100', 'text-gray-700', 'border-yellow-200', 'border-gray-200', 'border-green-200', 'bg-fuchsia-100', 'text-fuchsia-800', 'border-fuchsia-200');
                    messageBox.classList.add('bg-red-100', 'text-red-800', 'border-red-200');
                    messageBox.innerHTML = `üîí **Locked:** This square is **correct (Green)** and cannot be removed!`;
                    draw(true);
                    return false; 
                }
                
                let isPlacement = (oldValue === 0);

                if (isPlacement) { 
                    if (placementsThisRound.length < MAX_PLACEMENTS_PER_ROUND) {
                        userData[row][col] = 1;
                        currentBlackCount++;
                        placementsThisRound.push(currentCoords); 
                        if (hintIndex !== -1) hintedCells.splice(hintIndex, 1); 
                    } else {
                        moveAllowed = false; 
                    }
                } else { // Undo
                    if (lastCheckStatus[row][col] !== 1) { 
                        lastCheckStatus[row][col] = 0; 
                    }
                    userData[row][col] = 0;
                    currentBlackCount--;
                    
                    if (placementIndex !== -1) {
                        placementsThisRound.splice(placementIndex, 1); 
                    }
                    
                    if (hintIndex !== -1) {
                       hintedCells.splice(hintIndex, 1);
                    }
                    // Remove from pending history
                    pendingClickHistory = pendingClickHistory.filter(c => c.r !== row || c.c !== col);
                }

                if (!moveAllowed) {
                    messageBox.classList.remove('bg-green-100', 'text-green-800', 'bg-yellow-100', 'text-yellow-800', 'bg-gray-100', 'text-gray-700', 'border-yellow-200', 'border-gray-200', 'border-green-200', 'bg-fuchsia-100', 'text-fuchsia-800', 'border-fuchsia-200');
                    messageBox.classList.add('bg-red-100', 'text-red-800', 'border-red-200');
                    messageBox.innerHTML = `üõë **Placement limit reached!** You must undo one of your **${MAX_PLACEMENTS_PER_ROUND}** specific moves this round to place another.`;
                    draw(true);
                    return false; 
                }

                // Add to pending history ONLY if the move was a successful placement
                if (isPlacement && moveAllowed) {
                    const coordKey = `${row},${col}`;
                    if (!pendingClickHistory.some(c => c.key === coordKey)) {
                         pendingClickHistory.push({ r: row, c: col, key: coordKey });
                    }
                }

                if (lastCheckStatus[row][col] !== 1) {
                    lastCheckStatus[row][col] = 0; 
                }

                isCellChanged = true;
            }

            if (isHistoryVisible) {
                isHistoryVisible = false;
            }

            checkButton.disabled = false;
            checkButton.classList.remove('opacity-50', 'cursor-not-allowed');
            checkButton.classList.add('hover:bg-indigo-700');
            
            draw(true);
            
            const remaining = MAX_PLACEMENTS_PER_ROUND - placementsThisRound.length;
            statusMessage.textContent = `Target generated. Grid Size: ${GRID_WIDTH}x${GRID_HEIGHT}. Total black modules: ${totalSolutionBlack}. You have ${remaining} placements remaining this round.`;
            statusMessage.classList.remove('bg-red-100', 'bg-green-100', 'text-red-800', 'text-green-800', 'bg-yellow-200', 'text-yellow-900');
            statusMessage.classList.add('bg-blue-100', 'text-blue-800');
            
            return true;
        }

        function showCheckedSquares() {
            if (solutionData.length === 0 || isHistoryUsed) return; 

            isHistoryVisible = true; 
            isHistoryUsed = true;    
            updateCheckedSquaresButtonUI(); 

            messageBox.classList.remove('bg-yellow-100', 'bg-red-100', 'text-yellow-800', 'text-red-800', 'bg-gray-100', 'text-gray-700', 'border-red-200', 'border-gray-200', 'border-yellow-200');
            messageBox.classList.add('bg-fuchsia-100', 'text-fuchsia-800', 'border-fuchsia-200');
            messageBox.innerHTML = `üîÆ **Click History Revealed!** Purple ${puzzleMode === 'BARCODE' ? 'bars' : 'circles'} show every square you've successfully interacted with. Click any square to hide this overlay. **This button is now disabled for this puzzle.**`;

            draw(true);
        }

        // --- Interaction Handlers (Pan/Click/Drag/Pinch) ---
        
        function getTransformedCoordinates(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const translatedX = (x - panOffset.x) / scale;
            const translatedY = (y - panOffset.y) / scale;

            return { x: translatedX, y: translatedY };
        }

        function handleMouseDown(event) {
            event.preventDefault(); 
            
            if (event.touches && event.touches.length > 1) {
                isTouchDragging = false;
                previousDistance = getDistance(event.touches);
                return;
            }

            const clientX = event.clientX || (event.touches ? event.touches[0].clientX : 0);
            const clientY = event.clientY || (event.touches ? event.touches[0].clientY : 0);
            
            isDragging = true;
            isTouchDragging = !!event.touches; 
            isDrawing = false; 
            lastMousePos = { x: clientX, y: clientY };
            startClickPos = { x: clientX, y: clientY };
            lastDrawCell = {r: -1, c: -1};

            if (isTouchDragging || event.button === 0) { 
                dragTimer = setTimeout(() => {
                    isDrawing = true;
                    // Initial click registration
                    const { x, y } = getTransformedCoordinates(clientX, clientY);
                    const col = Math.floor(x / moduleWidth);
                    const row = Math.floor(y / moduleHeight);
                    if (row >= 0 && row < GRID_HEIGHT && col >= 0 && col < GRID_WIDTH && solutionData.length > 0) {
                         toggleCell(row, col);
                         lastDrawCell = {r: row, c: col};
                    }
                }, DRAG_DELAY_MS);
            }
            
            canvas.style.cursor = 'grab';
        }

        function handleMouseMove(event) {
            event.preventDefault();
            const isTouchEvent = !!event.touches;

            // --- 2-Finger Pinch Zoom Logic (Touch only) ---
            if (isTouchEvent && event.touches.length >= 2) {
                if (dragTimer) {
                    clearTimeout(dragTimer);
                    dragTimer = null;
                }
                isDragging = false; 
                isDrawing = false;
                isHistoryVisible = false; 

                const currentDistance = getDistance(event.touches);
                if (previousDistance === null) {
                    previousDistance = currentDistance;
                    return;
                }
                
                const factor = currentDistance / previousDistance;
                const oldScale = scale;
                
                let maxScale = puzzleMode === 'BARCODE' ? BARCODE_MAX_SCALE : MAX_SCALE;
                const newScale = Math.max(MIN_SCALE, Math.min(maxScale, scale * factor));

                if (newScale !== oldScale) {
                    const rect = canvas.getBoundingClientRect();
                    const touchCenterX = (event.touches[0].clientX + event.touches[1].clientX) / 2 - rect.left;
                    const touchCenterY = (event.touches[0].clientY + event.touches[1].clientY) / 2 - rect.top;

                    const pointX = (touchCenterX - panOffset.x) / oldScale;
                    const pointY = (touchCenterY - panOffset.y) / oldScale;
                    
                    scale = newScale;

                    panOffset.x = touchCenterX - (pointX * scale);
                    panOffset.y = touchCenterY - (pointY * scale);
                }

                previousDistance = currentDistance;
                draw(true);
                return;
            }
            
            // --- 1-Finger Drag/Pan/Draw Logic ---
            if (!isDragging) return;

            const clientX = event.clientX || (event.touches ? event.touches[0].clientX : 0);
            const clientY = event.clientY || (event.touches ? event.touches[0].clientY : 0);

            const dx = clientX - lastMousePos.x;
            const dy = clientY - lastMousePos.y;
            
            lastMousePos = { x: clientX, y: clientY };
            
            // --- DRAWING MODE (Priority 1) ---
            if (isDrawing) {
                const { x, y } = getTransformedCoordinates(clientX, clientY);
                const col = Math.floor(x / moduleWidth);
                const row = Math.floor(y / moduleHeight);

                // Barcodes toggle the whole column, so we only need to check if the column has changed
                if (puzzleMode === 'BARCODE' && col !== lastDrawCell.c) {
                    toggleCell(row, col);
                    lastDrawCell = {r: row, c: col};
                } else if (puzzleMode === 'QR' || puzzleMode === 'rMQR') {
                    if (row !== lastDrawCell.r || col !== lastDrawCell.c) {
                        toggleCell(row, col);
                        lastDrawCell = {r: row, c: col};
                    }
                }
                return; 
            }
            
            // --- PANNING MODE CHECK (Priority 2) ---
            
            const totalDx = clientX - startClickPos.x;
            const totalDy = clientY - startClickPos.y;
            
            if (Math.sqrt(totalDx * totalDx + totalDy * totalDy) > MOVEMENT_TOLERANCE) {
                if (dragTimer) {
                    clearTimeout(dragTimer);
                    dragTimer = null;
                }
                panOffset.x += dx;
                panOffset.y += dy;
                draw(true);
            }
        }

        function handleMouseUp(event) {
            previousDistance = null; 

            if (!isDragging) return;
            
            const clientX = event.clientX || (event.changedTouches ? event.changedTouches[0].clientX : 0);
            const clientY = event.clientY || (event.changedTouches ? event.changedTouches[0].clientY : 0);

            const dx = clientX - startClickPos.x;
            const dy = clientY - startClickPos.y;
            
            isDragging = false;
            isTouchDragging = false;
            canvas.style.cursor = 'grab';

            if (dragTimer) {
                clearTimeout(dragTimer);
                dragTimer = null;
            }

            // If it was a "click" (minimal movement AND timer didn't trigger drawing mode)
            if (!isDrawing && Math.sqrt(dx * dx + dy * dy) < MOVEMENT_TOLERANCE) {
                const { x, y } = getTransformedCoordinates(clientX, clientY);
                const col = Math.floor(x / moduleWidth);
                const row = Math.floor(y / moduleHeight);

                if (row >= 0 && row < GRID_HEIGHT && col >= 0 && col < GRID_WIDTH && solutionData.length > 0) {
                    toggleCell(row, col);
                }
            }
            
            isDrawing = false; 
        }

        function handleTouchEnd(event) {
            if (event.touches.length === 0) {
                 handleMouseUp(event);
            }
            previousDistance = null; 
        }

        function handleZoom(factor, clientX, clientY) {
            const oldScale = scale;
            
            let maxScale = puzzleMode === 'BARCODE' ? BARCODE_MAX_SCALE : MAX_SCALE;
            const newScale = Math.max(MIN_SCALE, Math.min(maxScale, scale * factor));

            if (newScale !== oldScale) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = clientX - rect.left;
                const mouseY = clientY - rect.top;

                const pointX = (mouseX - panOffset.x) / oldScale;
                const pointY = (mouseY - panOffset.y) / oldScale;
                
                scale = newScale;

                panOffset.x = mouseX - (pointX * scale);
                panOffset.y = mouseY - (pointY * scale);
            }

            draw(true);
        }

        function handleWheel(event) {
            event.preventDefault();
            const factor = event.deltaY < 0 ? 1.1 : 0.9;
            handleZoom(factor, event.clientX, event.clientY);
        }


        function resetView() {
            scale = 1.0;
            const drawWidth = GRID_WIDTH * moduleWidth;
            const drawHeight = GRID_HEIGHT * moduleHeight;
            panOffset = { 
                x: (CANVAS_DIMENSION - drawWidth) / 2, 
                y: (CANVAS_DIMENSION - drawHeight) / 2 
            };
            draw(true);
        }
        
        function wipeGrid() {
            if (solutionData.length > 0) {
                initializeGrid(GRID_WIDTH, GRID_HEIGHT); 
                
                const version = versionSelect.value;
                MAX_PLACEMENTS_PER_ROUND = MAX_PLACEMENTS_LOOKUP[version] || MAX_PLACEMENTS_LOOKUP.DEFAULT;

                messageBox.classList.remove('bg-red-100', 'bg-green-100', 'text-red-800', 'text-green-800', 'bg-yellow-100', 'text-yellow-800', 'border-red-200', 'border-green-200', 'border-yellow-200', 'bg-fuchsia-100', 'text-fuchsia-800', 'border-fuchsia-200');
                messageBox.classList.add('bg-gray-100', 'text-gray-700', 'border-gray-200');
                messageBox.innerHTML = `
                    <p><strong>Grid Wiped:</strong> Ready for a fresh start. History reset.</p>
                    <p class="mt-2 text-xs text-gray-500">Make your ${MAX_PLACEMENTS_PER_ROUND} placements and press 'Check Pattern' for the first hint!</p>
                `;

                draw(true);
                statusMessage.textContent = `Grid wiped. Paint the ${GRID_WIDTH}x${GRID_HEIGHT} pattern. Total black modules: ${totalSolutionBlack}. You have ${MAX_PLACEMENTS_PER_ROUND} placements remaining this round.`;
                statusMessage.classList.remove('bg-red-100', 'bg-green-100', 'text-red-800', 'text-green-800', 'bg-yellow-200', 'text-yellow-900');
                statusMessage.classList.add('bg-blue-100', 'text-blue-800');
                
                saveButton.style.display = 'none';
            } else {
                 statusMessage.textContent = `Please generate a target pattern first!`;
                 statusMessage.classList.remove('bg-blue-100', 'bg-green-100', 'text-blue-800', 'text-green-800', 'bg-yellow-200', 'text-yellow-900');
                 statusMessage.classList.add('bg-red-100', 'text-red-800');
            }
        }

        /**
         * Main initialization function.
         */
        window.onload = function() {
            canvas = document.getElementById('qrCanvas');
            ctx = canvas.getContext('2d');
            
            // Interaction: Mouse
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp); 
            
            // Interaction: Touch 
            canvas.addEventListener('touchstart', handleMouseDown, { passive: false });
            canvas.addEventListener('touchmove', handleMouseMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', handleTouchEnd);


            // Zoom/View
            canvas.addEventListener('wheel', handleWheel);
            document.getElementById('zoomInButton').addEventListener('click', (e) => handleZoom(1.2, e.clientX, e.clientY));
            document.getElementById('zoomOutButton').addEventListener('click', (e) => handleZoom(0.8, e.clientX, e.clientY));
            document.getElementById('resetViewButton').addEventListener('click', resetView);
            
            // UI Mode Listeners
            modeSelect.addEventListener('change', updateVersionSelectorVisibility);
            
            // Game Flow
            document.getElementById('generateButton').addEventListener('click', generateTarget);
            checkButton.addEventListener('click', checkPattern);
            document.getElementById('clearButton').addEventListener('click', wipeGrid);
            
            // Feature Listeners
            document.getElementById('saveButton').addEventListener('click', saveSolutionQrCode);
            hintButton.addEventListener('click', grantHint);
            checkedSquaresButton.addEventListener('click', showCheckedSquares);


            // Initial setup (Uses current default mode: QR Code, Version 1)
            updateVersionSelectorVisibility();
            initializeGrid(21, 21); // Default QR V1 size
            draw(true);
        };

    </script>
</body>
</html>
